{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Advanced Digital Design and Verification (ADDV)","text":"<p>Instructor &amp; Date</p> <p>Instructor: Sneh Saurabh Date: 12th August, 2025</p>"},{"location":"#course-objective","title":"\ud83c\udfaf Course Objective","text":"<ul> <li>Develop a basic understanding of methods, tools, and technologies for designing and verifying complex digital systems.</li> <li>Gain practical skills in advanced design and verification methodologies.</li> </ul>"},{"location":"#expected-outcomes","title":"\ud83d\udccc Expected Outcomes","text":"By the end of this course <ul> <li>Apply various tasks in pre-RTL design.</li> <li>Evaluate trade-offs during design stages.</li> <li>Implement advanced functional verification techniques.</li> <li>Design and verify systems at multiple abstraction levels using CAD tools.</li> </ul>"},{"location":"#pre-requisites","title":"\ud83e\uddd1\u200d\ud83d\udcbb Pre-requisites","text":"<p>Tip</p> <ul> <li>VLSI Design Flow (ECE313/ECE513)  </li> <li>C++ or OOP concepts  </li> <li>Familiarity with SystemC and SystemVerilog</li> </ul>"},{"location":"#applications","title":"\ud83d\udca1 Applications","text":"<p>Where will this be useful?</p> <ul> <li>Semiconductor industry (system level)</li> <li>VLSI, CAD, FPGA, Embedded Systems, Computer Architecture</li> <li>System-level design efforts &amp; innovation areas</li> </ul>"},{"location":"#course-content-overview","title":"\ud83d\uddc2 Course Content Overview","text":"Week Topics 1 Introduction; Digital systems; Software &amp; hardware design flows; Manufacturing &amp; test 2 ESL Design \u2013 SystemC Models, TLM, Virtual Platforms, Platform-based Design 3 Hardware-software co-design \u2013 models, exploration, partitioning, co-simulation 4-5 High-level Synthesis \u2013 flow, CDFG, optimizations, scheduling, pipelining 6 SoC Design Methodology \u2013 IP packaging, IP-XACT, RTL generation 7-10 SystemVerilog, advanced simulation, formal verification, UVM, CDC/RDC 11-13 Power management, UPF, design flows"},{"location":"#evaluation","title":"\ud83d\udcdd Evaluation","text":"<ul> <li>Weekly Assignments: 25%  </li> <li>Mid-semester Exam: 30%  </li> <li>End-semester Exam: 45%  </li> </ul>"},{"location":"#references","title":"\ud83d\udcda References","text":"CoreSupplementary <ul> <li>Saurabh, S. (2023). Introduction to VLSI Design Flow, Cambridge University Press.</li> </ul> <ul> <li>Black, D. C., &amp; Donovan, J. (2004). SystemC: From the Ground Up, Springer US.  </li> <li>Martin, G., Bailey, B., &amp; Piziali, A. (2010). ESL Design and Verification, Elsevier.  </li> <li>Spear, C. (2008). SystemVerilog for Verification, Springer.  </li> <li>Micheli, G. D. (1994). Synthesis and Optimization of Digital Circuits, McGraw-Hill.</li> </ul>"},{"location":"#policies","title":"\ud83d\udcdc Policies","text":"<p>Attendance</p> <p>Less than 30% attendance may result in a FAIL grade.  </p> <p>Plagiarism</p> <p>Strictly prohibited \u2014 IIIT Delhi rules apply.</p> <p>Deadlines</p> <ul> <li>20% penalty per day late </li> <li>After 5 days = zero marks</li> </ul>"},{"location":"#contact-office-hours","title":"\ud83d\udcde Contact &amp; Office Hours","text":"InstructorTAs <ul> <li>Wed: 12:30\u20131:30 pm (B-608)</li> </ul> <ul> <li>Varun: Tue/Thu 3:00\u20134:30 pm (C210)</li> </ul>"},{"location":"week1/lecture1/","title":"Week 1 \u2014 Lecture 1: Electronic Systems &amp; Implementation","text":"<p>Course &amp; Lecture Info</p> <p>Course: Advanced Digital Design and Verification (ADDV) Instructor: Sneh Saurabh Lecture: Week 1, Lecture 1 \u2014 Introduction to Systems, Components, and Implementation </p>"},{"location":"week1/lecture1/#learning-goals","title":"Learning Goals","text":"<ul> <li>Define an electronic system and its elements.</li> <li>Distinguish hardware, software, and other components in real systems.</li> <li>Classify processors (fixed-behavior vs customizable) and related compute elements (coprocessors, microcontrollers, ASICs).</li> <li>Recognize major memory categories.</li> <li>Outline the hardware and software implementation flows.</li> <li>Understand verification, manufacturing &amp; test, and system integration &amp; validation at a high level.</li> </ul>"},{"location":"week1/lecture1/#1-what-is-a-system","title":"1) What is a System?","text":"<p>A system is a combination of elements that function together to produce the capability required to meet a need.</p> <p>Elements may include: hardware, software, equipment, facilities, personnel, and processes.</p> <p>Electronic systems: systems designed to sense, process, and manipulate electronic signals. Examples: mobile phone, computer, robot, television, EEG machine, etc.</p>"},{"location":"week1/lecture1/#systemelement-relationships-concept-map","title":"System/Element relationships (concept map)","text":"<pre><code>flowchart TD\n    A[System Need] --&gt; B[System]\n    B --&gt; C[Elements]\n    C --&gt; C1[Hardware]\n    C --&gt; C2[Software]\n    C --&gt; C3[Equipment &amp; Facilities]\n    C --&gt; C4[Personnel]\n    C --&gt; C5[Processes]\n    B --&gt; D[Capabilities Produced]\n    D --&gt; E[Meets the Need]</code></pre>"},{"location":"week1/lecture1/#2-components-of-electronic-systems","title":"2) Components of Electronic Systems","text":"<p>Systems often comprise numerous subsystems built with diverse technologies; the overall functionality is richer than individual parts.</p> At a glance <pre><code>flowchart TD\n    S[\"Electronic System\"] --&gt; H[\"Hardware\"]\n    S --&gt; SW[\"Software\"]\n    S --&gt; O[\"Other Components\"]\n\n    H --&gt; H1[\"Processing\"]\n    H --&gt; H2[\"Storage (Memory)\"]\n    H --&gt; H3[\"Sensing\"]\n    H --&gt; H4[\"Communication\"]\n\n    SW --&gt; SW1[\"System SW (OS, drivers)\"]\n    SW --&gt; SW2[\"Dev Tools (compiler, linker, debugger)\"]\n    SW --&gt; SW3[\"Application SW (GP/Specialized)\"]\n    SW --&gt; SW4[\"Firmware\"]\n\n    O --&gt; O1[\"Packaging &amp; PCBs\"]\n    O --&gt; O2[\"Mechanical parts (hinges, keyboard)\"]\n    O --&gt; O3[\"Power &amp; Thermal\"]\n</code></pre> Key notes <ul> <li>Hardware (electronic): compute, memory, sensors/actuators, I/O and comms.  </li> <li>Software: system software, development toolchain, application software, firmware.  </li> <li>Other components: packaging, PCB, mechanical parts, power delivery, etc.</li> </ul>"},{"location":"week1/lecture1/#3-hardware-processor-types","title":"3) Hardware: Processor Types","text":"<p>Instruction-set/architecture determines customizability.</p> <pre><code>flowchart LR\n    P[Processors] --&gt; F[Fixed Behavior]\n    P --&gt; C[Customizable]</code></pre>"},{"location":"week1/lecture1/#31-fixed-behavior-processors","title":"3.1 Fixed-Behavior Processors","text":"<ul> <li> <p>General-purpose: designed for broad computing requirements (e.g., x86, ARM cores).</p> </li> <li> <p>Special-purpose: optimized for specific tasks (power, speed, area):</p> <ul> <li> <p>DSP processors</p> </li> <li> <p>Image/vision processors</p> </li> <li> <p>NPUs/TPUs (neural/tensor processing)</p> </li> <li> <p>GPUs</p> </li> </ul> </li> </ul> <pre><code>flowchart TD\n    FB[Fixed Behavior] --&gt; GP[General Purpose CPU]\n    FB --&gt; SP[Special Purpose]\n    SP --&gt; SP1[DSP]\n    SP --&gt; SP2[Image/Video]\n    SP --&gt; SP3[NPU/TPU]\n    SP --&gt; SP4[GPU]</code></pre>"},{"location":"week1/lecture1/#32-customizable-processors","title":"3.2 Customizable Processors","text":"<ul> <li> <p>ASIP (Application-Specific Instruction-set Processors): add custom instructions for domain PPA gains.</p> </li> <li> <p>Configurable cores: cache sizes, pipeline depth, functional units, interfaces.</p> </li> <li> <p>Commercial examples include families like Xtensa and ARC-V with full toolchains.</p> </li> </ul> <pre><code>flowchart TD\n    C[\"Customizable\"] --&gt; ASIP[\"ASIP (Extend ISA)\"]\n    C --&gt; CFG[\"Configurable Core\"]\n\n    ASIP --&gt; T1[\"Custom Instructions\"]\n    ASIP --&gt; T2[\"Compiler/Toolchain Support\"]\n\n    CFG --&gt; P1[\"Pipeline/Issue Width\"]\n    CFG --&gt; P2[\"Cache Sizes/Hierarchy\"]\n    CFG --&gt; P3[\"Custom Interfaces/Accelerators\"]\n</code></pre>"},{"location":"week1/lecture1/#4-coprocessors","title":"4) Coprocessors","text":"<p>Definition: An auxiliary processor that supplements the main CPU for certain tasks (e.g., floating-point, graphics, signal processing, crypto, I/O, AI/vision).</p> <p>Why use them?</p> <ul> <li> <p>Optimized for specific algorithms \u2192 better performance/Watt.</p> </li> <li> <p>Let the main CPU remain simpler (can reduce cost/power in some products).</p> </li> <li> <p>Over time, popular coprocessor functions may migrate into CPUs.</p> </li> </ul> <pre><code>flowchart LR\n    CPU[Main CPU] -- offload --&gt; X1[FPU]\n    CPU -- offload --&gt; X2[GPU]\n    CPU -- offload --&gt; X3[AI/Vision]\n    CPU -- offload --&gt; X4[Crypto/Compression]\n    CPU -- offload --&gt; X5[Signal Processing]</code></pre>"},{"location":"week1/lecture1/#5-microcontrollers-mcus","title":"5) Microcontrollers (MCUs)","text":"<p>One chip integrating CPU core(s) + memory + programmable I/O + peripherals. Often used in embedded/real-time systems (robotics, automotive, medical, IoT).</p> <ul> <li> <p>Typical features</p> <ul> <li> <p>GPIO (input mode: read sensors; output mode: drive LEDs/motors via power stages)</p> </li> <li> <p>Timers/counters, watchdog</p> </li> <li> <p>ADC/DAC, comparators</p> </li> <li> <p>UART/SPI/I\u00b2C/CAN/etc.</p> </li> <li> <p>On-chip Flash and SRAM</p> </li> </ul> </li> </ul> <pre><code>flowchart TB\n    subgraph MCU[\"Microcontroller (single IC)\"]\n      CORE[\"Processor Core\"]\n      MEM[\"Flash + SRAM\"]\n      BUS[\"Internal Bus\"]\n      TIM[\"Timers / PWM\"]\n      GPIO[\"GPIO\"]\n      ADC[\"ADC / DAC\"]\n      COMM[\"UART / SPI / I2C / CAN\"]\n    end\n\n    CORE -- \"fetch/exec\" --&gt; MEM\n    CORE &lt;---&gt; BUS\n    BUS &lt;---&gt; TIM\n    BUS &lt;---&gt; GPIO\n    BUS &lt;---&gt; ADC\n    BUS &lt;---&gt; COMM\n\n    GPIO --&gt; OUT[\"Actuators/Motors (via drivers)\"]\n    GPIO --&gt; IN[\"Sensors/Buttons\"]\n    ADC --&gt; SENS[\"Analog Sensors\"]\n</code></pre> <p>Microcontroller vs SoC: an SoC is generally broader (may integrate multi-core CPUs, GPUs, memory controllers, etc.). An SoC can include MCU-like subsystems.</p>"},{"location":"week1/lecture1/#6-asics","title":"6) ASICs","text":"<p>Application-Specific Integrated Circuits \u2014 designed for a specific application rather than general use.</p> <ul> <li> <p>May integrate multiple processors, memories, accelerators, and peripherals.</p> </li> <li> <p>Complex ASICs \u2248 SoCs.</p> </li> </ul> <p>Example application domains</p> <ul> <li> <p>Networking</p> </li> <li> <p>Security</p> </li> <li> <p>Voice processing</p> </li> <li> <p>Video encode/decode</p> </li> <li> <p>Storage and I/O controllers</p> </li> </ul> <pre><code>flowchart TB\n    subgraph ASIC[\"ASIC / SoC (high-level)\"]\n      CPU1[CPU Cluster]\n      ACC1[Domain Accelerator]\n      MEM1[SRAM/TCAM/Cache]\n      PERI[I/O Peripherals]\n      BUS1[Interconnect/Fabric]\n      PWR[Power/Clock/Reset]\n    end\n    CPU1 &lt;--&gt; BUS1\n    ACC1 &lt;--&gt; BUS1\n    MEM1 &lt;--&gt; BUS1\n    PERI &lt;--&gt; BUS1\n    PWR --&gt; CPU1\n    PWR --&gt; ACC1\n    PWR --&gt; MEM1\n    PWR --&gt; PERI</code></pre>"},{"location":"week1/lecture1/#7-memory-landscape","title":"7) Memory Landscape","text":"<pre><code>flowchart TB\n    M[\"Memory\"] --&gt; NVM[\"ROM (Non-Volatile)\"]\n    M --&gt; VM[\"RAM (Volatile)\"]\n    M --&gt; EXT[\"External Storage\"]\n\n    NVM --&gt; PROM[\"PROM\"]\n    NVM --&gt; EPROM[\"EPROM\"]\n    NVM --&gt; FLASH[\"Flash\"]\n\n    VM --&gt; SRAM[\"SRAM\"]\n    VM --&gt; DRAM[\"DRAM\"]\n\n    EXT --&gt; HDD[\"Hard Disk\"]\n    EXT --&gt; ODD[\"Optical (CD/DVD)\"]\n    EXT --&gt; USB[\"USB Flash\"]\n</code></pre> <p>Notes</p> <ul> <li> <p>NVM/ROM: retains data without power (PROM/EPROM/Flash).</p> </li> <li> <p>RAM: fast working memory (SRAM for on-chip caches; DRAM for main memory).</p> </li> <li> <p>External: system-level storage devices.</p> </li> </ul>"},{"location":"week1/lecture1/#8-software-components","title":"8) Software Components","text":"<p>Categories</p> <ul> <li> <p>System Software: OS, device drivers, boot/firmware.</p> </li> <li> <p>Software Development Tools: compiler, assembler, linker, loader, debugger, profilers, CI.</p> </li> <li> <p>Application Software: end-user applications (general-purpose or domain-specific).</p> </li> <li> <p>Firmware: machine instructions embedded in devices (cameras, phones, NICs, printers, routers, remotes).</p> </li> </ul> <pre><code>flowchart LR\n    SW[Software] --&gt; SYS[System SW]\n    SW --&gt; DEV[Dev Toolchain]\n    SW --&gt; APP[Application SW]\n    SW --&gt; FWM[Firmware]\n\n    SYS --&gt; OS[Operating System]\n    SYS --&gt; DRV[Device Drivers]\n    SYS --&gt; BOOT[Boot / BIOS / UEFI]\n    DEV --&gt; COMP[Compiler/Assembler]\n    DEV --&gt; LINK[Linker/Loader]\n    DEV --&gt; DBG[Debugger/Profiler]\n    APP --&gt; GP[General Purpose]\n    APP --&gt; SPEC[Specialized/Domain]</code></pre>"},{"location":"week1/lecture1/#9-hardware-software-in-a-mobile-device-conceptual","title":"9) Hardware + Software in a Mobile Device (conceptual)","text":"<pre><code>flowchart TB\n    subgraph Phone[\"Mobile Phone (Conceptual Stack)\"]\n      subgraph HW[\"Hardware\"]\n        RF[\"RF Front-end\"]\n        AP[\"Application Processor / SoC\"]\n        MEM[\"LPDDR / eMMC / UFS\"]\n        PER[\"Peripherals: Sensor, Display, Camera, Audio, BT/WiFi\"]\n        PWR[\"PMIC/Battery\"]\n      end\n      subgraph SWStack[\"Software\"]\n        K[\"Linux Kernel / RTOS\"]\n        HAL[\"Hardware Abstraction Layer\"]\n        SS[\"System Services &amp; Daemons\"]\n        RT[\"Runtime (e.g., Android Runtime)\"]\n        API[\"System APIs\"]\n        APP[\"Apps (System/Privileged/3rd-party)\"]\n      end\n    end\n\n    HW --&gt; SWStack\n    API --&gt; APP\n    SS --&gt; RT\n    HAL --&gt; K\n    K --&gt; AP\n    AP --&gt; MEM\n    AP --&gt; PER\n</code></pre>"},{"location":"week1/lecture1/#10-system-implementation-birds-eye-view","title":"10) System Implementation \u2014 Bird\u2019s-Eye View","text":"<pre><code>flowchart TD\n    SF[System Functionality / Requirements] --&gt; PART[Partitioning]\n    PART --&gt; HWF[HW Functionality]\n    PART --&gt; SWF[SW Functionality]\n    HWF --&gt; IC[IC Design &amp; Fabrication]\n    IC --&gt; FAB[Fabricated ICs/SoCs/Peripherals]\n    SWF --&gt; SWDEV[Software Development]\n    SWDEV --&gt; EXE[Executables: Firmware, Drivers, Apps]\n    FAB --&gt; INT[System Integration, Validation &amp; Test]\n    EXE --&gt; INT\n    INT --&gt; PROD[Product]</code></pre> <p>Project-level actions</p> <ol> <li> <p>Map functionality to HW vs SW.</p> </li> <li> <p>Build components     A. HW design, verification, fabrication     B. SW development</p> </li> <li> <p>Integrate and validate the combined system.</p> </li> </ol>"},{"location":"week1/lecture1/#11-hardware-design-implementation","title":"11) Hardware Design Implementation","text":"<p>Two major transformations:</p> <ul> <li> <p>Logic Synthesis: Convert RTL \u2192 equivalent netlist (in target library).</p> </li> <li> <p>Physical Design: Convert netlist \u2192 layout (GDS) ready for fabrication.</p> </li> </ul> <pre><code>flowchart LR\n    RTL[\"RTL\"] --&gt; SYN[\"Logic Synthesis\"]\n    SYN --&gt; NET[\"Gate-level Netlist\"]\n    NET --&gt; PD[\"Physical Design\"]\n    PD --&gt; LAYOUT[\"Layout (GDS)\"]\n    LAYOUT --&gt; FAB[\"Fabrication\"]\n</code></pre> <p>Typical physical design tasks</p> <pre><code>flowchart TB\n    A[Netlist] --&gt; B[Chip Planning / Floorplanning]\n    B --&gt; C[Placement]\n    C --&gt; D[Clock Tree Synthesis]\n    D --&gt; E[Global Routing]\n    E --&gt; F[Detailed Routing]\n    F --&gt; G[ECO/Design Fixes]\n    G --&gt; H[Write GDS]</code></pre>"},{"location":"week1/lecture1/#12-hardware-design-verification","title":"12) Hardware Design Verification","text":"<p>Goal: Ensure the design implements the intended functionality under constraints. Performed at multiple stages of the VLSI flow.</p> <ul> <li> <p>Functional Verification</p> <ul> <li> <p>Simulation-based (directed, random, constrained random, coverage-driven)</p> </li> <li> <p>Formal methods (property checking, model checking)</p> </li> <li> <p>Equivalence checking (e.g., RTL vs netlist)</p> </li> </ul> </li> <li> <p>Physical Verification</p> <ul> <li> <p>DRC, ERC, LVS</p> </li> <li> <p>Signal integrity, IR drop, timing (STA), variation analysis</p> </li> <li> <p>Sign-off checks</p> </li> </ul> </li> </ul> <pre><code>flowchart TD\n    V[Verification] --&gt; FV[Functional Verification]\n    V --&gt; PV[Physical Verification]\n    FV --&gt; SIM[Simulation-based]\n    FV --&gt; FORM[Formal Methods]\n    FV --&gt; EQ[Equivalence Checking]\n    PV --&gt; DRC[DRC/ERC/LVS]\n    PV --&gt; STA[STA &amp; Timing Reports]\n    PV --&gt; SI[SI/IR drop/EM]</code></pre>"},{"location":"week1/lecture1/#13-hardware-manufacturing-test","title":"13) Hardware Manufacturing &amp; Test","text":"<p>Input: Final GDS from physical design. Output: Chips that pass production test.</p> <pre><code>flowchart TD\n    G[GDS] --&gt; PRE[Pre-process &amp; Mask Prep]\n    PRE --&gt; WAF[Wafer Fabrication]\n    WAF --&gt; DIE[Die Testing]\n    DIE --&gt; PKG[Packaging]\n    PKG --&gt; FT[Final Testing]\n    FT --&gt; CHIP[Chips Shipped]</code></pre> <p>Device-level test loop (ATE)</p> <pre><code>flowchart LR\n    TP[Test Patterns] --&gt; DIEU[Die Under Test]\n    ER[Expected Responses] --&gt; CMP{Match?}\n    DIEU --&gt; AR[Actual Responses]\n    AR --&gt; CMP\n    ER --&gt; CMP\n    CMP -- Yes --&gt; PASS[Test Pass / Accept]\n    CMP -- No --&gt; FAIL[Test Fail / Reject/Diagnose]</code></pre>"},{"location":"week1/lecture1/#14-software-development-process","title":"14) Software Development Process","text":"<pre><code>flowchart TD\n    PLAN[\"Planning &amp; Requirement Analysis\"] --&gt; ARCH[\"Designing Architecture\"]\n    ARCH --&gt; CODE[\"Implementation / Coding\"]\n    CODE --&gt; TEST[\"Testing (manual &amp; automated)\"]\n    TEST --&gt; DEP[\"Deployment &amp; Integration\"]\n    DEP --&gt; MAINT[\"Maintenance (bug fixes, enhancements, support)\"]\n</code></pre> <ul> <li> <p>Planning: resources, schedules, functional and technical definitions, documentation.</p> </li> <li> <p>Architecture: layers, modules, responsibilities, technology selection.</p> </li> <li> <p>Implementation: compilers/interpreters, build systems, debuggers used to produce executables.</p> </li> <li> <p>Testing: unit/integration/system/regression; automation &amp; CI.</p> </li> <li> <p>Deployment: delivery to target environment; integration with other components.</p> </li> <li> <p>Maintenance: fixes, performance optimization, new features.</p> </li> </ul>"},{"location":"week1/lecture1/#15-system-integration-validation","title":"15) System Integration &amp; Validation","text":"<p>Integration begins as components become available. It surfaces interface/integration issues early.</p> <ul> <li> <p>Validation highlights</p> <ul> <li> <p>Run actual OS/applications on fabricated silicon or accurate platforms.</p> </li> <li> <p>Exercise system-level scenarios not covered in unit tests.</p> </li> <li> <p>Find electrical issues (crosstalk, IR drop, thermal, variation).</p> </li> <li> <p>Stress/soak tests and corner/abuse cases.</p> </li> </ul> </li> </ul> <pre><code>flowchart TD\n    FAB[Fabricated HW/Platform] --&gt; INT[System Integration]\n    EXE[SW: Firmware/Drivers/Apps] --&gt; INT\n    INT --&gt; VAL[Validation]\n    VAL --&gt; PROD[Ship Product]</code></pre>"},{"location":"week1/lecture1/#key-takeaways","title":"Key Takeaways","text":"<ul> <li> <p>Electronic systems combine hardware + software + other disciplines to meet a defined need.</p> </li> <li> <p>Compute choices range from fixed-behavior CPUs/accelerators to customizable ASIPs.</p> </li> <li> <p>MCUs integrate compute + peripherals on one die for embedded control; ASICs/SoCs tailor whole chips to applications.</p> </li> <li> <p>The VLSI flow transforms RTL \u2192 netlist \u2192 layout while verification ensures correctness.</p> </li> <li> <p>Manufacturing &amp; ATE confirm defect-free parts; integration/validation demonstrates end-to-end behavior.</p> </li> </ul>"},{"location":"week1/lecture1/#references-further-reading","title":"References &amp; Further Reading","text":"<ul> <li>Saurabh, S. (2023). Introduction to VLSI Design Flow. Cambridge University Press.</li> </ul>"}]}
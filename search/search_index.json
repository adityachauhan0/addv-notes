{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Advanced Digital Design and Verification (ADDV)","text":"<p>Instructor: Sneh Saurabh Date: 12th August, 2025</p>"},{"location":"#about-the-course","title":"About the Course","text":"<p>Objective: - Develop a basic understanding of methods, tools, and technologies for designing and verifying complex digital systems. - Gain practical skills in advanced design and verification methodologies.</p> <p>Expected Outcomes: - Apply various tasks in pre-RTL design. - Evaluate trade-offs during design stages. - Implement advanced functional verification techniques. - Design and verify systems at multiple abstraction levels using CAD tools.</p>"},{"location":"#pre-requisites","title":"Pre-requisites","text":"<ul> <li>VLSI Design Flow (ECE313/ECE513)</li> <li>C++ or OOP concepts</li> <li>Familiarity with SystemC and SystemVerilog</li> </ul>"},{"location":"#applications","title":"Applications","text":"<ul> <li>Semiconductor industry (system level)</li> <li>VLSI, CAD, FPGA, Embedded Systems, Computer Architecture</li> <li>System-level manual design efforts and innovation areas</li> </ul>"},{"location":"#course-content-overview","title":"Course Content Overview","text":"<ol> <li>Week 1: Introduction; Digital systems; Software and hardware design flows; Manufacturing and test  </li> <li>Week 2: ESL Design \u2013 SystemC Models, TLM, Virtual Platforms, Platform-based Design  </li> <li>Week 3: Hardware-software co-design \u2013 models, exploration, partitioning, co-simulation  </li> <li>Week 4-5: High-level Synthesis \u2013 flow, CDFG, optimizations, scheduling, pipelining  </li> <li>Week 6: SoC Design Methodology \u2013 IP packaging, IP-XACT, RTL generation  </li> <li>Week 7-10: SystemVerilog, advanced simulation, formal verification, UVM, CDC/RDC  </li> <li>Week 11-13: Power management, UPF, design flows</li> </ol>"},{"location":"#evaluation","title":"Evaluation","text":"<ul> <li>Weekly Assignments: 25%  </li> <li>Mid-semester Exam: 30%  </li> <li>End-semester Exam: 45%</li> </ul>"},{"location":"#references","title":"References","text":"<ul> <li>Saurabh, S. (2023). Introduction to VLSI Design Flow, Cambridge University Press.  </li> <li>Black, D. C., &amp; Donovan, J. (2004). SystemC: From the Ground Up, Springer US.  </li> <li>Martin, G., Bailey, B., &amp; Piziali, A. (2010). ESL Design and Verification, Elsevier.  </li> <li>Spear, C. (2008). SystemVerilog for Verification, Springer.  </li> <li>Micheli, G. D. (1994). Synthesis and Optimization of Digital Circuits, McGraw-Hill.</li> </ul>"},{"location":"#policies","title":"Policies","text":"<ul> <li>Attendance: &lt; 30% attendance may result in FAIL grade.</li> <li>Submission Deadlines: 20% penalty per day late; after 5 days = zero marks.</li> <li>Plagiarism: Strictly prohibited; IIIT Delhi rules apply.</li> </ul>"},{"location":"#contact-office-hours","title":"Contact &amp; Office Hours","text":"<p>Instructor: - Wed 12:30\u20131:30 pm (B-608)  </p> <p>TAs: - Varun \u2013 Tue/Thu 3:00\u20134:30 pm (C210)  </p>"},{"location":"week1/lecture1/","title":"Week 1 \u2014 Lecture 1: Electronic Systems &amp; Implementation","text":"<p>Course &amp; Lecture Info</p> <p>Course: Advanced Digital Design and Verification (ADDV) Instructor: Sneh Saurabh Lecture: Week 1, Lecture 1 \u2014 Introduction to Systems, Components, and Implementation </p>"},{"location":"week1/lecture1/#learning-goals","title":"Learning Goals","text":"<ul> <li>Define an electronic system and its elements.</li> <li>Distinguish hardware, software, and other components in real systems.</li> <li>Classify processors (fixed-behavior vs customizable) and related compute elements (coprocessors, microcontrollers, ASICs).</li> <li>Recognize major memory categories.</li> <li>Outline the hardware and software implementation flows.</li> <li>Understand verification, manufacturing &amp; test, and system integration &amp; validation at a high level.</li> </ul>"},{"location":"week1/lecture1/#1-what-is-a-system","title":"1) What is a System?","text":"<p>A system is a combination of elements that function together to produce the capability required to meet a need.</p> <p>Elements may include: hardware, software, equipment, facilities, personnel, and processes.</p> <p>Electronic systems: systems designed to sense, process, and manipulate electronic signals. Examples: mobile phone, computer, robot, television, EEG machine, etc.</p>"},{"location":"week1/lecture1/#systemelement-relationships-concept-map","title":"System/Element relationships (concept map)","text":"<pre><code>flowchart TD\n    A[System Need] --&gt; B[System]\n    B --&gt; C[Elements]\n    C --&gt; C1[Hardware]\n    C --&gt; C2[Software]\n    C --&gt; C3[Equipment &amp; Facilities]\n    C --&gt; C4[Personnel]\n    C --&gt; C5[Processes]\n    B --&gt; D[Capabilities Produced]\n    D --&gt; E[Meets the Need]</code></pre>"},{"location":"week1/lecture1/#2-components-of-electronic-systems","title":"2) Components of Electronic Systems","text":"<p>Systems often comprise numerous subsystems built with diverse technologies; the overall functionality is richer than individual parts.</p> At a glance <pre><code>flowchart TD\n    S[\"Electronic System\"] --&gt; H[\"Hardware\"]\n    S --&gt; SW[\"Software\"]\n    S --&gt; O[\"Other Components\"]\n\n    H --&gt; H1[\"Processing\"]\n    H --&gt; H2[\"Storage (Memory)\"]\n    H --&gt; H3[\"Sensing\"]\n    H --&gt; H4[\"Communication\"]\n\n    SW --&gt; SW1[\"System SW (OS, drivers)\"]\n    SW --&gt; SW2[\"Dev Tools (compiler, linker, debugger)\"]\n    SW --&gt; SW3[\"Application SW (GP/Specialized)\"]\n    SW --&gt; SW4[\"Firmware\"]\n\n    O --&gt; O1[\"Packaging &amp; PCBs\"]\n    O --&gt; O2[\"Mechanical parts (hinges, keyboard)\"]\n    O --&gt; O3[\"Power &amp; Thermal\"]\n</code></pre> Key notes <ul> <li>Hardware (electronic): compute, memory, sensors/actuators, I/O and comms.  </li> <li>Software: system software, development toolchain, application software, firmware.  </li> <li>Other components: packaging, PCB, mechanical parts, power delivery, etc.</li> </ul>"},{"location":"week1/lecture1/#3-hardware-processor-types","title":"3) Hardware: Processor Types","text":"<p>Instruction-set/architecture determines customizability.</p> <pre><code>flowchart LR\n    P[Processors] --&gt; F[Fixed Behavior]\n    P --&gt; C[Customizable]</code></pre>"},{"location":"week1/lecture1/#31-fixed-behavior-processors","title":"3.1 Fixed-Behavior Processors","text":"<ul> <li> <p>General-purpose: designed for broad computing requirements (e.g., x86, ARM cores).</p> </li> <li> <p>Special-purpose: optimized for specific tasks (power, speed, area):</p> <ul> <li> <p>DSP processors</p> </li> <li> <p>Image/vision processors</p> </li> <li> <p>NPUs/TPUs (neural/tensor processing)</p> </li> <li> <p>GPUs</p> </li> </ul> </li> </ul> <pre><code>flowchart TD\n    FB[Fixed Behavior] --&gt; GP[General Purpose CPU]\n    FB --&gt; SP[Special Purpose]\n    SP --&gt; SP1[DSP]\n    SP --&gt; SP2[Image/Video]\n    SP --&gt; SP3[NPU/TPU]\n    SP --&gt; SP4[GPU]</code></pre>"},{"location":"week1/lecture1/#32-customizable-processors","title":"3.2 Customizable Processors","text":"<ul> <li> <p>ASIP (Application-Specific Instruction-set Processors): add custom instructions for domain PPA gains.</p> </li> <li> <p>Configurable cores: cache sizes, pipeline depth, functional units, interfaces.</p> </li> <li> <p>Commercial examples include families like Xtensa and ARC-V with full toolchains.</p> </li> </ul> <pre><code>flowchart TD\n    C[\"Customizable\"] --&gt; ASIP[\"ASIP (Extend ISA)\"]\n    C --&gt; CFG[\"Configurable Core\"]\n\n    ASIP --&gt; T1[\"Custom Instructions\"]\n    ASIP --&gt; T2[\"Compiler/Toolchain Support\"]\n\n    CFG --&gt; P1[\"Pipeline/Issue Width\"]\n    CFG --&gt; P2[\"Cache Sizes/Hierarchy\"]\n    CFG --&gt; P3[\"Custom Interfaces/Accelerators\"]\n</code></pre>"},{"location":"week1/lecture1/#4-coprocessors","title":"4) Coprocessors","text":"<p>Definition: An auxiliary processor that supplements the main CPU for certain tasks (e.g., floating-point, graphics, signal processing, crypto, I/O, AI/vision).</p> <p>Why use them?</p> <ul> <li> <p>Optimized for specific algorithms \u2192 better performance/Watt.</p> </li> <li> <p>Let the main CPU remain simpler (can reduce cost/power in some products).</p> </li> <li> <p>Over time, popular coprocessor functions may migrate into CPUs.</p> </li> </ul> <pre><code>flowchart LR\n    CPU[Main CPU] -- offload --&gt; X1[FPU]\n    CPU -- offload --&gt; X2[GPU]\n    CPU -- offload --&gt; X3[AI/Vision]\n    CPU -- offload --&gt; X4[Crypto/Compression]\n    CPU -- offload --&gt; X5[Signal Processing]</code></pre>"},{"location":"week1/lecture1/#5-microcontrollers-mcus","title":"5) Microcontrollers (MCUs)","text":"<p>One chip integrating CPU core(s) + memory + programmable I/O + peripherals. Often used in embedded/real-time systems (robotics, automotive, medical, IoT).</p> <ul> <li> <p>Typical features</p> <ul> <li> <p>GPIO (input mode: read sensors; output mode: drive LEDs/motors via power stages)</p> </li> <li> <p>Timers/counters, watchdog</p> </li> <li> <p>ADC/DAC, comparators</p> </li> <li> <p>UART/SPI/I\u00b2C/CAN/etc.</p> </li> <li> <p>On-chip Flash and SRAM</p> </li> </ul> </li> </ul> <pre><code>flowchart TB\n    subgraph MCU[\"Microcontroller (single IC)\"]\n      CORE[\"Processor Core\"]\n      MEM[\"Flash + SRAM\"]\n      BUS[\"Internal Bus\"]\n      TIM[\"Timers / PWM\"]\n      GPIO[\"GPIO\"]\n      ADC[\"ADC / DAC\"]\n      COMM[\"UART / SPI / I2C / CAN\"]\n    end\n\n    CORE -- \"fetch/exec\" --&gt; MEM\n    CORE &lt;---&gt; BUS\n    BUS &lt;---&gt; TIM\n    BUS &lt;---&gt; GPIO\n    BUS &lt;---&gt; ADC\n    BUS &lt;---&gt; COMM\n\n    GPIO --&gt; OUT[\"Actuators/Motors (via drivers)\"]\n    GPIO --&gt; IN[\"Sensors/Buttons\"]\n    ADC --&gt; SENS[\"Analog Sensors\"]\n</code></pre> <p>Microcontroller vs SoC: an SoC is generally broader (may integrate multi-core CPUs, GPUs, memory controllers, etc.). An SoC can include MCU-like subsystems.</p>"},{"location":"week1/lecture1/#6-asics","title":"6) ASICs","text":"<p>Application-Specific Integrated Circuits \u2014 designed for a specific application rather than general use.</p> <ul> <li> <p>May integrate multiple processors, memories, accelerators, and peripherals.</p> </li> <li> <p>Complex ASICs \u2248 SoCs.</p> </li> </ul> <p>Example application domains</p> <ul> <li> <p>Networking</p> </li> <li> <p>Security</p> </li> <li> <p>Voice processing</p> </li> <li> <p>Video encode/decode</p> </li> <li> <p>Storage and I/O controllers</p> </li> </ul> <pre><code>flowchart TB\n    subgraph ASIC[\"ASIC / SoC (high-level)\"]\n      CPU1[CPU Cluster]\n      ACC1[Domain Accelerator]\n      MEM1[SRAM/TCAM/Cache]\n      PERI[I/O Peripherals]\n      BUS1[Interconnect/Fabric]\n      PWR[Power/Clock/Reset]\n    end\n    CPU1 &lt;--&gt; BUS1\n    ACC1 &lt;--&gt; BUS1\n    MEM1 &lt;--&gt; BUS1\n    PERI &lt;--&gt; BUS1\n    PWR --&gt; CPU1\n    PWR --&gt; ACC1\n    PWR --&gt; MEM1\n    PWR --&gt; PERI</code></pre>"},{"location":"week1/lecture1/#7-memory-landscape","title":"7) Memory Landscape","text":"<pre><code>flowchart TB\n    M[\"Memory\"] --&gt; NVM[\"ROM (Non-Volatile)\"]\n    M --&gt; VM[\"RAM (Volatile)\"]\n    M --&gt; EXT[\"External Storage\"]\n\n    NVM --&gt; PROM[\"PROM\"]\n    NVM --&gt; EPROM[\"EPROM\"]\n    NVM --&gt; FLASH[\"Flash\"]\n\n    VM --&gt; SRAM[\"SRAM\"]\n    VM --&gt; DRAM[\"DRAM\"]\n\n    EXT --&gt; HDD[\"Hard Disk\"]\n    EXT --&gt; ODD[\"Optical (CD/DVD)\"]\n    EXT --&gt; USB[\"USB Flash\"]\n</code></pre> <p>Notes</p> <ul> <li> <p>NVM/ROM: retains data without power (PROM/EPROM/Flash).</p> </li> <li> <p>RAM: fast working memory (SRAM for on-chip caches; DRAM for main memory).</p> </li> <li> <p>External: system-level storage devices.</p> </li> </ul>"},{"location":"week1/lecture1/#8-software-components","title":"8) Software Components","text":"<p>Categories</p> <ul> <li> <p>System Software: OS, device drivers, boot/firmware.</p> </li> <li> <p>Software Development Tools: compiler, assembler, linker, loader, debugger, profilers, CI.</p> </li> <li> <p>Application Software: end-user applications (general-purpose or domain-specific).</p> </li> <li> <p>Firmware: machine instructions embedded in devices (cameras, phones, NICs, printers, routers, remotes).</p> </li> </ul> <pre><code>flowchart LR\n    SW[Software] --&gt; SYS[System SW]\n    SW --&gt; DEV[Dev Toolchain]\n    SW --&gt; APP[Application SW]\n    SW --&gt; FWM[Firmware]\n\n    SYS --&gt; OS[Operating System]\n    SYS --&gt; DRV[Device Drivers]\n    SYS --&gt; BOOT[Boot / BIOS / UEFI]\n    DEV --&gt; COMP[Compiler/Assembler]\n    DEV --&gt; LINK[Linker/Loader]\n    DEV --&gt; DBG[Debugger/Profiler]\n    APP --&gt; GP[General Purpose]\n    APP --&gt; SPEC[Specialized/Domain]</code></pre>"},{"location":"week1/lecture1/#9-hardware-software-in-a-mobile-device-conceptual","title":"9) Hardware + Software in a Mobile Device (conceptual)","text":"<pre><code>flowchart TB\n    subgraph Phone[\"Mobile Phone (Conceptual Stack)\"]\n      subgraph HW[\"Hardware\"]\n        RF[\"RF Front-end\"]\n        AP[\"Application Processor / SoC\"]\n        MEM[\"LPDDR / eMMC / UFS\"]\n        PER[\"Peripherals: Sensor, Display, Camera, Audio, BT/WiFi\"]\n        PWR[\"PMIC/Battery\"]\n      end\n      subgraph SWStack[\"Software\"]\n        K[\"Linux Kernel / RTOS\"]\n        HAL[\"Hardware Abstraction Layer\"]\n        SS[\"System Services &amp; Daemons\"]\n        RT[\"Runtime (e.g., Android Runtime)\"]\n        API[\"System APIs\"]\n        APP[\"Apps (System/Privileged/3rd-party)\"]\n      end\n    end\n\n    HW --&gt; SWStack\n    API --&gt; APP\n    SS --&gt; RT\n    HAL --&gt; K\n    K --&gt; AP\n    AP --&gt; MEM\n    AP --&gt; PER\n</code></pre>"},{"location":"week1/lecture1/#10-system-implementation-birds-eye-view","title":"10) System Implementation \u2014 Bird\u2019s-Eye View","text":"<pre><code>flowchart TD\n    SF[System Functionality / Requirements] --&gt; PART[Partitioning]\n    PART --&gt; HWF[HW Functionality]\n    PART --&gt; SWF[SW Functionality]\n    HWF --&gt; IC[IC Design &amp; Fabrication]\n    IC --&gt; FAB[Fabricated ICs/SoCs/Peripherals]\n    SWF --&gt; SWDEV[Software Development]\n    SWDEV --&gt; EXE[Executables: Firmware, Drivers, Apps]\n    FAB --&gt; INT[System Integration, Validation &amp; Test]\n    EXE --&gt; INT\n    INT --&gt; PROD[Product]</code></pre> <p>Project-level actions</p> <ol> <li> <p>Map functionality to HW vs SW.</p> </li> <li> <p>Build components     A. HW design, verification, fabrication     B. SW development</p> </li> <li> <p>Integrate and validate the combined system.</p> </li> </ol>"},{"location":"week1/lecture1/#11-hardware-design-implementation","title":"11) Hardware Design Implementation","text":"<p>Two major transformations:</p> <ul> <li> <p>Logic Synthesis: Convert RTL \u2192 equivalent netlist (in target library).</p> </li> <li> <p>Physical Design: Convert netlist \u2192 layout (GDS) ready for fabrication.</p> </li> </ul> <pre><code>flowchart LR\n    RTL[\"RTL\"] --&gt; SYN[\"Logic Synthesis\"]\n    SYN --&gt; NET[\"Gate-level Netlist\"]\n    NET --&gt; PD[\"Physical Design\"]\n    PD --&gt; LAYOUT[\"Layout (GDS)\"]\n    LAYOUT --&gt; FAB[\"Fabrication\"]\n</code></pre> <p>Typical physical design tasks</p> <pre><code>flowchart TB\n    A[Netlist] --&gt; B[Chip Planning / Floorplanning]\n    B --&gt; C[Placement]\n    C --&gt; D[Clock Tree Synthesis]\n    D --&gt; E[Global Routing]\n    E --&gt; F[Detailed Routing]\n    F --&gt; G[ECO/Design Fixes]\n    G --&gt; H[Write GDS]</code></pre>"},{"location":"week1/lecture1/#12-hardware-design-verification","title":"12) Hardware Design Verification","text":"<p>Goal: Ensure the design implements the intended functionality under constraints. Performed at multiple stages of the VLSI flow.</p> <ul> <li> <p>Functional Verification</p> <ul> <li> <p>Simulation-based (directed, random, constrained random, coverage-driven)</p> </li> <li> <p>Formal methods (property checking, model checking)</p> </li> <li> <p>Equivalence checking (e.g., RTL vs netlist)</p> </li> </ul> </li> <li> <p>Physical Verification</p> <ul> <li> <p>DRC, ERC, LVS</p> </li> <li> <p>Signal integrity, IR drop, timing (STA), variation analysis</p> </li> <li> <p>Sign-off checks</p> </li> </ul> </li> </ul> <pre><code>flowchart TD\n    V[Verification] --&gt; FV[Functional Verification]\n    V --&gt; PV[Physical Verification]\n    FV --&gt; SIM[Simulation-based]\n    FV --&gt; FORM[Formal Methods]\n    FV --&gt; EQ[Equivalence Checking]\n    PV --&gt; DRC[DRC/ERC/LVS]\n    PV --&gt; STA[STA &amp; Timing Reports]\n    PV --&gt; SI[SI/IR drop/EM]</code></pre>"},{"location":"week1/lecture1/#13-hardware-manufacturing-test","title":"13) Hardware Manufacturing &amp; Test","text":"<p>Input: Final GDS from physical design. Output: Chips that pass production test.</p> <pre><code>flowchart TD\n    G[GDS] --&gt; PRE[Pre-process &amp; Mask Prep]\n    PRE --&gt; WAF[Wafer Fabrication]\n    WAF --&gt; DIE[Die Testing]\n    DIE --&gt; PKG[Packaging]\n    PKG --&gt; FT[Final Testing]\n    FT --&gt; CHIP[Chips Shipped]</code></pre> <p>Device-level test loop (ATE)</p> <pre><code>flowchart LR\n    TP[Test Patterns] --&gt; DIEU[Die Under Test]\n    ER[Expected Responses] --&gt; CMP{Match?}\n    DIEU --&gt; AR[Actual Responses]\n    AR --&gt; CMP\n    ER --&gt; CMP\n    CMP -- Yes --&gt; PASS[Test Pass / Accept]\n    CMP -- No --&gt; FAIL[Test Fail / Reject/Diagnose]</code></pre>"},{"location":"week1/lecture1/#14-software-development-process","title":"14) Software Development Process","text":"<pre><code>flowchart TD\n    PLAN[\"Planning &amp; Requirement Analysis\"] --&gt; ARCH[\"Designing Architecture\"]\n    ARCH --&gt; CODE[\"Implementation / Coding\"]\n    CODE --&gt; TEST[\"Testing (manual &amp; automated)\"]\n    TEST --&gt; DEP[\"Deployment &amp; Integration\"]\n    DEP --&gt; MAINT[\"Maintenance (bug fixes, enhancements, support)\"]\n</code></pre> <ul> <li> <p>Planning: resources, schedules, functional and technical definitions, documentation.</p> </li> <li> <p>Architecture: layers, modules, responsibilities, technology selection.</p> </li> <li> <p>Implementation: compilers/interpreters, build systems, debuggers used to produce executables.</p> </li> <li> <p>Testing: unit/integration/system/regression; automation &amp; CI.</p> </li> <li> <p>Deployment: delivery to target environment; integration with other components.</p> </li> <li> <p>Maintenance: fixes, performance optimization, new features.</p> </li> </ul>"},{"location":"week1/lecture1/#15-system-integration-validation","title":"15) System Integration &amp; Validation","text":"<p>Integration begins as components become available. It surfaces interface/integration issues early.</p> <ul> <li> <p>Validation highlights</p> <ul> <li> <p>Run actual OS/applications on fabricated silicon or accurate platforms.</p> </li> <li> <p>Exercise system-level scenarios not covered in unit tests.</p> </li> <li> <p>Find electrical issues (crosstalk, IR drop, thermal, variation).</p> </li> <li> <p>Stress/soak tests and corner/abuse cases.</p> </li> </ul> </li> </ul> <pre><code>flowchart TD\n    FAB[Fabricated HW/Platform] --&gt; INT[System Integration]\n    EXE[SW: Firmware/Drivers/Apps] --&gt; INT\n    INT --&gt; VAL[Validation]\n    VAL --&gt; PROD[Ship Product]</code></pre>"},{"location":"week1/lecture1/#key-takeaways","title":"Key Takeaways","text":"<ul> <li> <p>Electronic systems combine hardware + software + other disciplines to meet a defined need.</p> </li> <li> <p>Compute choices range from fixed-behavior CPUs/accelerators to customizable ASIPs.</p> </li> <li> <p>MCUs integrate compute + peripherals on one die for embedded control; ASICs/SoCs tailor whole chips to applications.</p> </li> <li> <p>The VLSI flow transforms RTL \u2192 netlist \u2192 layout while verification ensures correctness.</p> </li> <li> <p>Manufacturing &amp; ATE confirm defect-free parts; integration/validation demonstrates end-to-end behavior.</p> </li> </ul>"},{"location":"week1/lecture1/#references-further-reading","title":"References &amp; Further Reading","text":"<ul> <li>Saurabh, S. (2023). Introduction to VLSI Design Flow. Cambridge University Press.</li> </ul>"},{"location":"week1/lecture2/","title":"Week 1 \u2013 Lecture 2: Electronic System Level (ESL) Design","text":"<p>Course: Advanced Digital Design and Verification Instructor: Sneh Saurabh \u2022 Date: 14 Aug 2025</p>"},{"location":"week1/lecture2/#tldr","title":"TL;DR","text":"<ul> <li>Move up the abstraction stack (ESL) to fight SoC complexity.</li> <li>Create an executable specification \u2192 analyze \u2192 partition HW/SW \u2192 implement \u2192 verify \u2192 iterate.</li> <li>Use TLM, SystemC, VIPs, and HLS/ISS/virtual platforms to accelerate design + verification.</li> </ul>"},{"location":"week1/lecture2/#motivation","title":"Motivation","text":"<p>Why RTL-first breaks in modern SoCs</p> <ul> <li>More features, more HW+SW, more comms \u2192 time \u2191, cost \u2191, FoM compromises.</li> <li>Strict time-to-market makes long RTL cycles risky.</li> </ul> <p>Counter-move</p> <ul> <li>Higher-level abstraction (ESL) to boost design efficiency and parallelize HW/SW development.</li> </ul> <p>Effects vs Fix</p> Pain ESL Relief Long design time Early modeling + architectural exploration Costly late changes Fast iteration at high abstraction FoM compromises Early analysis of power/area/perf trade-offs Verification bottlenecks Co-verification, VIPs, mixed-abstraction TBs"},{"location":"week1/lecture2/#what-is-esl","title":"What is ESL?","text":"<p>A higher-level executable abstraction of the system that is above RTL, aimed at comprehension, exploration, and early verification.</p> <p>Expectations</p> <ul> <li>Time-to-result \u2193, FoM \u2191, cost-effective, concurrent HW/SW development.</li> </ul>"},{"location":"week1/lecture2/#abstraction-contrast","title":"Abstraction contrast","text":"<pre><code>flowchart LR\n  spec[\"Specification\"]\n  rtl[\"RTL (HDL)\"]\n  gds[\"Layout (GDS)\"]\n  esl[\"ESL\"]\n\n  spec -- Manual Effort --&gt; rtl;\n  rtl --&gt; gds;\n  spec -- ESL Modeling --&gt; esl;\n  esl --&gt; rtl;\n\n  classDef low fill:#eeeeee,stroke:#999,color:#333;\n  class rtl,gds low;\n\n````\n\n---\n\n## ESL Flow (big picture)\n\n```mermaid\nflowchart LR\n    S[Specification]\n    M[ESL Model]\n    A[Analyze]\n    F{Acceptable?}\n    P[Partition]\n    SW[SW Model]\n    HW[HW Model]\n    D[Analyze &amp; Debug]\n    OK[Acceptable]\n    SI[SW Implementation]\n    HI[HW Implementation]\n    PV[Post-Partitioning Verification]\n    MOD[Modify]\n\n    S--&gt;M--&gt;A--&gt;F\n    F -- \"No\" --&gt; MOD --&gt; M\n    F -- \"Yes\" --&gt; P\n    P --&gt; SW --&gt; D\n    P --&gt; HW --&gt; D\n    D --&gt;|Refine| SW\n    D --&gt;|Refine| HW\n    D --&gt; OK\n    OK --&gt; SI &amp; HI --&gt; PV\n    PV --&gt;|Issues| MOD</code></pre>"},{"location":"week1/lecture2/#decisions-deliverables-at-esl","title":"Decisions &amp; Deliverables at ESL","text":"<ul> <li> <p>Architectural exploration/estimation/optimization</p> <ul> <li> <p>Concurrency: sequential / parallel / pipelined / multithreaded</p> </li> <li> <p>Communication: bus / buffered / memory / point-to-point</p> </li> <li> <p>Functional adequacy: algorithm choice, arbitration, data representation (fixed vs float)</p> </li> </ul> </li> <li> <p>HW\u2013SW partitioning with fewer experiments</p> </li> <li> <p>Parallel SW development before HW exists</p> </li> <li> <p>IP &amp; HW\u2013SW integration</p> </li> <li> <p>RTL generation</p> </li> <li> <p>Faster verification (mixed abstraction, auto TB scaffolding)</p> </li> </ul>"},{"location":"week1/lecture2/#specifications-executable-specs","title":"Specifications &amp; Executable Specs","text":"<p>What counts as an executable spec?</p> <ul> <li>A runnable functional/behavioral model that exhibits intended behavior.  </li> <li>Tech: SystemC, TLM, SystemVerilog, MATLAB, XML, IP-XACT, SDL.</li> </ul>"},{"location":"week1/lecture2/#levels-of-executable-spec","title":"Levels of executable spec","text":"<pre><code>flowchart TB\n  AS[\"Architecture Spec\\n(ISA, behaviors, features)\"]\n  DS[\"Design Spec\\n(uarch: pipeline, caches, counts)\"]\n  TLM[\"Transaction-Level Modeling\\n(bus transactions, timing options)\"]\n\n  AS --&gt; DS --&gt; TLM\n</code></pre> <p>Good spec attributes</p> <ul> <li>Complete &amp; precise functional requirements + constraints  </li> <li>Avoid premature platform details  </li> <li>Evolves with refinement; supports mixing abstraction levels </li> <li>Source of truth for requirements \u2192 implementation \u2192 verification</li> </ul>"},{"location":"week1/lecture2/#analysis-modifications-at-esl","title":"Analysis &amp; Modifications at ESL","text":"<ul> <li> <p>Pre-partition: time/space/power/complexity/TTM trade-offs</p> </li> <li> <p>Static: maintainability, usability, criticality, reliability</p> </li> <li> <p>Dynamic: latency/throughput, arbitration/scheduling effects</p> </li> <li> <p>Reqs for analysis: computation (fixed/float), comms (bandwidth)</p> </li> </ul>"},{"location":"week1/lecture2/#partitioning-hw-vs-sw","title":"Partitioning (HW vs SW)","text":"<pre><code>flowchart TD\n  E[\"Executable Spec\"] --&gt; C{\"Criteria\"};\n\n  C --&gt;|Perf target| HW1[\"HW Candidate\"];\n  C --&gt;|Flexibility| SW1[\"SW Candidate\"];\n  C --&gt;|Area/Power| HW2[\"Accelerator\"];\n  C --&gt;|Safety/Security| HW3[\"Isolated IP\"];\n  C --&gt;|Reuse| SW2[\"FW / Driver\"];\n\n  HW1 --&gt; HWAs[\"HW Subsystem\"];\n  HW2 --&gt; HWAs;\n  HW3 --&gt; HWAs;\n\n  SW1 --&gt; SWAs[\"SW Subsystem\"];\n  SW2 --&gt; SWAs;\n\n  HWAs --&gt; IF[\"Defined Interfaces (TLM/AMBA/etc)\"];\n  SWAs --&gt; IF;\n</code></pre> <p>Decide also:</p> <ul> <li> <p>Memory org: ROM/SRAM/DRAM/\u2026</p> </li> <li> <p>Interconnect/communication scheme</p> </li> <li> <p>Sub-partitioning across multiple CPUs and multiple HW teams</p> </li> </ul>"},{"location":"week1/lecture2/#and-type-of-processors-and-potential-isa-changes","title":"and type of processors (and potential ISA changes)","text":""},{"location":"week1/lecture2/#post-partitioning-analysis-debug-verification","title":"Post-partitioning: Analysis, Debug, Verification","text":"<ul> <li> <p>Analysis: performance, interfaces, area, cost, debugability</p> </li> <li> <p>Debug: run SW on ISS; model HW with SystemC/HDL; ensure interface compatibility</p> </li> <li> <p>Verification planning @ higher abstraction:</p> <ul> <li> <p>Coverage at TLM</p> </li> <li> <p>Assertions/properties at the same level</p> </li> <li> <p>Mixed-abstraction environments (e.g., TLM + RTL)</p> </li> </ul> </li> <li> <p>Iterate if intent not preserved.</p> </li> </ul> <pre><code>sequenceDiagram\n    participant Spec\n    participant ESL\n    participant Part as Partition\n    participant SW as SW Model/ISS\n    participant HW as HW Model/RTL\n    participant Ver as Post-Part Verify\n    Spec-&gt;&gt;ESL: Executable spec\n    ESL-&gt;&gt;Part: Analyze &amp; Partition\n    Part-&gt;&gt;SW: Build SW model\n    Part-&gt;&gt;HW: Build HW model\n    SW--&gt;&gt;Ver: Stimulus/Results\n    HW--&gt;&gt;Ver: Stimulus/Results\n    Ver--&gt;&gt;ESL: Issues? -&gt; Modify &amp; Iterate</code></pre>"},{"location":"week1/lecture2/#software-implementation-models","title":"Software Implementation Models","text":""},{"location":"week1/lecture2/#waterfall-pre-esl","title":"Waterfall (pre-ESL)","text":"<ul> <li>Linear, sequential; late feedback.</li> </ul>"},{"location":"week1/lecture2/#spiral-with-esl","title":"Spiral (with ESL)","text":"<ul> <li>Iterative, risk-driven; SW &amp; HW co-evolve.</li> </ul> <pre><code>gantt\n    dateFormat  X\n    title Waterfall vs Spiral (conceptual)\n    section Waterfall\n    Requirements   :a1, 1, 2\n    Design         :a2, 3, 2\n    Implement      :a3, 5, 2\n    Integrate/Test :a4, 7, 2\n    section Spiral (overlapping)\n    Prototype/Model(ESL)   :b1, 1, 1\n    Risk Analysis          :b2, 2, 1\n    Build/Refine           :b3, 2, 2\n    Evaluate/Plan Next     :b4, 4, 1\n    Next Spiral            :b5, 5, 3</code></pre>"},{"location":"week1/lecture2/#applying-esl-to-software","title":"Applying ESL to Software","text":"<ul> <li> <p>Generate SW from ESL or refined models (software synthesis) or hand-code guided by the model.</p> </li> <li> <p>Observability into HW via models.</p> </li> <li> <p>Scope</p> <ul> <li> <p>ISS: CPU regs/mem visible</p> </li> <li> <p>Virtual Platform: full SoC (user I/F, storage, accelerators)</p> </li> </ul> </li> <li> <p>Exec platforms: workstation, FPGA-based emulation</p> </li> <li> <p>Metrics: speed, memory footprint</p> </li> </ul> <pre><code>flowchart LR\n  SSW[\"Software\"];\n  ISS[\"Hardware Model (ISS)\"];\n  VP((\"Virtual Platform\"));\n\n  SSW &lt;--&gt; ISS;\n  SSW --&gt; VP;\n  ISS --&gt; VP;\n</code></pre>"},{"location":"week1/lecture2/#debuggability","title":"Debuggability","text":"Approach Pros Cons HW trace buffers Real silicon visibility Area/perf cost, security concerns ESL-based PC/data trace from models, no HW cost Model fidelity limits, discipline"},{"location":"week1/lecture2/#hardware-implementation-paths","title":"Hardware Implementation Paths","text":"<ul> <li>RTL to gates via synthesis.</li> </ul> <p>Options</p> <ol> <li> <p>Extensible processors (custom instructions, SIMD/MAC) + vendor toolchains</p> </li> <li> <p>Co-processors (DSP/VLIW attached on bus)</p> </li> <li> <p>ASIC (HLS from C/C++/SystemC \u2192 RTL)</p> </li> <li> <p>FPGA (rapid prototyping; same HLS path)</p> </li> </ol> <pre><code>graph LR\n    H[ESL/C/C++/SystemC] --&gt; HLS[High-Level Synthesis]\n    HLS --&gt; RTL[RTL]\n    RTL --&gt; ASIC[ASIC Flow]\n    RTL --&gt; FPGA[FPGA Flow]</code></pre>"},{"location":"week1/lecture2/#implementation-verification","title":"Implementation Verification","text":"<ul> <li> <p>Verify implementation preserves design intent (compare to post-partition model).</p> </li> <li> <p>Speed tricks: subsystem-level focus, mixed abstraction, FPGA prototypes.</p> </li> <li> <p>Pass/Fail notions</p> <ul> <li> <p>Positive: requirement satisfied (valid inputs)</p> </li> <li> <p>Negative: robustness (invalid inputs)</p> </li> </ul> </li> </ul>"},{"location":"week1/lecture2/#verification-ips-vips","title":"Verification IPs (VIPs)","text":"<ul> <li>Reusable verification components.</li> </ul> <pre><code>flowchart LR\n    VIP[Verification IP]\n    VIP --&gt;|Dynamic| Dyn[Stimulus, Scoreboard, Coverage]\n    VIP --&gt;|Static| Sta[Assertions/Properties]</code></pre>"},{"location":"week1/lecture2/#systemc-primer","title":"SystemC Primer","text":""},{"location":"week1/lecture2/#history-state","title":"History &amp; State","text":"<pre><code>timeline\n    title SystemC Key Milestones\n    1996 : Development starts\n    2002 : OSCI releases v2.0 proposal\n    2006 : IEEE Std 1666-2005\n    2023 : Ref Impl v3.0.0 (GitHub)</code></pre>"},{"location":"week1/lecture2/#why-systemc","title":"Why SystemC?","text":"<ul> <li> <p>Bridges SW/HW; models parallelism in familiar C++.</p> </li> <li> <p>Any valid C++ program is valid SystemC (it\u2019s an extension).</p> </li> <li> <p>Heavy use of templates/macros/libs.</p> </li> </ul>"},{"location":"week1/lecture2/#simulation-pipeline","title":"Simulation Pipeline","text":"<pre><code>flowchart TD\n  Dev[\"C++ Dev Env\"];\n  Comp[\"Compile\"];\n  LinkStep[\"Link\"];\n  Exe[\"Executable\"];\n  RunStep[\"Run on Host (Win/Unix)\"];\n  Result[\"Simulation Results\"];\n\n  Dev --&gt; Comp;\n  Comp --&gt; LinkStep;\n  LinkStep --&gt; Exe;\n  Exe --&gt; RunStep;\n  RunStep --&gt; Result;\n</code></pre>"},{"location":"week1/lecture2/#systemc-hello-world","title":"SystemC \u201cHello, World!\u201d","text":"<pre><code>#include &lt;systemc.h&gt;\n\nSC_MODULE(Hello_SystemC) {\n    SC_CTOR(Hello_SystemC) {\n        SC_THREAD(module_thread); // register thread process\n    }\n    void module_thread() {\n        SC_REPORT_INFO(\"Module Thread Saying\", \"Hello SystemC World!\");\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Hello_SystemC HelloWorld_i(\"HelloWorld_i\"); // create instance\n    sc_start();                                  // start simulator (run to time 0 unless events)\n    return 0;\n}\n</code></pre>"},{"location":"week1/lecture2/#compile-example","title":"Compile (example)","text":"<pre><code># from the directory with main.cpp\ng++ -I&lt;path_to_systemc_include&gt; -L&lt;path_to_systemc_lib&gt; main.cpp -lsystemc -o hello_sc\n./hello_sc\n</code></pre> <p>Checklist before compiling</p> <ul> <li><code>g++</code> installed  </li> <li><code>-I</code> points to <code>systemc/include</code> </li> <li><code>-L</code> points to the lib directory (e.g., <code>lib-linux64</code>)  </li> <li>Link with <code>-lsystemc</code> </li> <li>If runtime can\u2019t find the shared lib, set <code>LD_LIBRARY_PATH</code> (Linux) or use <code>rpath</code>.</li> </ul>"},{"location":"week1/lecture2/#quick-study-guide","title":"Quick Study Guide","text":"<ul> <li> <p>Explain ESL vs RTL and why abstraction helps.</p> </li> <li> <p>Draw the ESL flow (spec \u2192 model \u2192 analyze \u2192 partition \u2192 implement \u2192 verify).</p> </li> <li> <p>List 3 partitioning criteria and 3 analysis types.</p> </li> <li> <p>Contrast Waterfall vs Spiral for SW in SoC context.</p> </li> <li> <p>Name two execution platforms for ESL-driven SW dev.</p> </li> <li> <p>Sketch SystemC toolchain from code to sim results.</p> </li> </ul>"}]}